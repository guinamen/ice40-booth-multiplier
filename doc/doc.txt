================================================================================
PROJECT: High-Performance 16-bit Booth Radix-8 Multiplier (Soft-Core) v2.0
PLATFORM: Lattice iCE40 FPGA
AUTHOR: Guilherme Namen
REPOSITORY: https://github.com/guinamen/ice40-booth-multiplier
LICENSE: MIT
================================================================================

1. EXECUTIVE SUMMARY
--------------------------------------------------------------------------------
This document details the architecture and performance of a highly optimized 
16-bit multiplier IP Core designed for the Lattice iCE40 FPGA family.

The primary goal was to create a high-speed multiplication unit using only soft 
logic (LUTs and Carry Chains), avoiding the usage of hard-wired DSP blocks. 
Through a combination of **Parallel Booth Radix-8**, **Flattened Control Logic**, 
and a **Split-Adder Topology**, the core achieves an operating frequency of 
**~145 MHz** and a deterministic latency of just **5 cycles** (~34.5ns).

Notably, this version achieves a simultaneous improvement in Power, Performance, 
and Area (PPA) compared to previous iterations, delivering higher speed while 
consuming fewer logic resources (~5% of iCE40HX8K).

2. ARCHITECTURAL DESIGN & METHODS
--------------------------------------------------------------------------------
The design overcomes the traditional trade-off between Area and Speed through
four distinct engineering methods:

2.1. PARALLEL DECOMPOSITION (DIVIDE AND CONQUER)
The 16-bit operation is decomposed into four independent 8-bit cores running
in parallel:
    - P0 (Low x Low)
    - P1 (High x Low)
    - P2 (Low x High)
    - P3 (High x High)
    This reduces the depth of internal carry chains and improves routing efficiency.

2.2. BOOTH RADIX-8 WITH MAGNITUDE SYMMETRY
    Standard Booth implementations often suffer from complex decoding logic.
    This design uses **Magnitude Symmetry** to map positive and negative Booth
    encodings to the same absolute values, reducing the Multiplexer complexity.
    Processing 3 bits per cycle reduces the iterative loop to just 3 steps.

2.3. CRITICAL PATH OPTIMIZATION: FLATTENED CONTROL MUX
    The bottleneck in FPGA multipliers is often the logic depth before the adder.
    
    Method:
    Instead of a cascaded "Decode -> Select -> Invert -> Add" path, this design
    calculates selection signals (1x, 2x, 3x, 4x) and inversion flags in parallel
    using "Flattened" logic. The 3x term is still pre-calculated in the setup
    cycle ("Look-Ahead"), but the selection logic now fits into a single level 
    of LUTs before the carry chain.

    Gain:
    - Reduced logic depth from ~13 levels to ~9 levels inside the loop.
    - Enabled the reduction of pipeline latency from 7 cycles to 5 cycles.

2.4. TOP-LEVEL OPTIMIZATION: SPLIT-ADDER TOPOLOGY
    The final recombination of the 32-bit result (P3<<16 + P2<<8 + P1<<8 + P0)
    traditionally uses a full 32-bit adder chain, which is slow.

    Method:
    We exploit the fact that the lower 8 bits of the result come purely from P0
    and require no addition. The adder is split into:
    1. An 18-bit intermediate adder for the middle terms (P1+P2).
    2. A 24-bit final adder for the upper section.
    
    Gain:
    This effectively cuts ~8 bits of carry propagation delay from the critical path, 
    boosting Fmax from ~133 MHz to ~145 MHz.

3. PERFORMANCE BENCHMARKS
--------------------------------------------------------------------------------
Synthesis and Timing Analysis were performed using Yosys and Nextpnr for the
iCE40HX8K-CT256 FPGA (Speed Grade 1).

3.1. COMPARISON: SERIAL VS. BOOTH V1 VS. BOOTH V2 (FINAL)

    METRIC              | SERIAL STD    | BOOTH V1    | BOOTH V2 (FINAL)
    --------------------|---------------|-------------|---------------------
    Max Frequency (Fmax)| 96.85 MHz     | 133.62 MHz  | 144.93 MHz
    Clock Cycles        | 17 Cycles     | 7 Cycles    | 5 Cycles
    Total Time (Latency)| ~175.4 ns     | ~52.4 ns    | ~34.5 ns
    Logic Cells (Area)  | ~342 LCs      | ~488 LCs    | ~407 LCs

3.2. ANALYSIS
    - Speed: The V2 core is **~5.1x faster** in total execution time compared
      to the standard serial approach.
    - Efficiency: Surprisingly, the V2 core is smaller (~407 LCs) than the V1
      implementation due to the removal of complex conditional logic in favor
      of flattened bitwise operations.
    - Area: Occupies only ~5% of an iCE40HX8K device.

4. INTERFACE SPECIFICATIONS
--------------------------------------------------------------------------------
    PORT           | WIDTH | DIR | DESCRIPTION
    ---------------|-------|-----|--------------------------------------------
    clk            | 1     | IN  | System Clock
    rst_n          | 1     | IN  | Active-low Reset
    start          | 1     | IN  | One-cycle pulse to trigger multiplication
    multiplicand   | 16    | IN  | Operand A
    multiplier     | 16    | IN  | Operand B
    sign_mode      | 2     | IN  | 00:UxU, 01:UxS, 10:SxU, 11:SxS
    product        | 32    | OUT | Result (Available when done=1)
    done           | 1     | OUT | Pulse high when calculation completes
    busy           | 1     | OUT | High while operation is in progress

5. CONCLUSION
--------------------------------------------------------------------------------
The "Booth V2" optimization represents a significant milestone in soft-core
arithmetic design. By manually optimizing the datapath to align with the FPGA's 
LUT4 architecture—specifically through **Flattened Control** and **Split Addition**—
we achieved a design that is faster, lower latency, and smaller than previous 
iterations. This core proves that high-performance arithmetic (>140 MHz) is 
achievable on low-cost FPGAs without dedicated DSP hardware.
