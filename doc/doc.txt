================================================================================
PROJECT: High-Performance 16-bit Booth Radix-8 Multiplier (Soft-Core)
PLATFORM: Lattice iCE40 FPGA
AUTHOR: Guilherme Namen
REPOSITORY: https://github.com/guinamen/ice40-booth-multiplier
LICENSE: MIT
================================================================================

1. EXECUTIVE SUMMARY
--------------------------------------------------------------------------------
This document details the architecture and performance of a specialized 16-bit
multiplier IP Core designed for the Lattice iCE40 FPGA family.

The primary goal was to create a high-speed multiplication unit using only soft 
logic (LUTs and Carry Chains), avoiding the usage of hard-wired DSP blocks. 
By implementing a Parallel Booth Radix-8 algorithm with specific timing 
optimizations, the core achieves an operating frequency of >133 MHz and a total
latency of 52ns, significantly outperforming standard serial implementations.

2. ARCHITECTURAL DESIGN & METHODS
--------------------------------------------------------------------------------
The design overcomes the traditional trade-off between Area and Speed through
three distinct engineering methods:

2.1. PARALLEL DECOMPOSITION (DIVIDE AND CONQUER)
Instead of implementing a monolithic 16-bit Booth multiplier, the design
decomposes the operation into four independent 8-bit multiplications:
    - P0: Low  x Low
    - P1: High x Low
    - P2: Low  x High
    - P3: High x High

    Method:
    These four cores run in parallel. The final result is reconstructed using 
    combinational logic: Result = (P3 << 16) + (P2 << 8) + (P1 << 8) + P0.

    Gain:
    This reduces the depth of the internal carry chains and the complexity of
    the multiplexers inside each core, improving routing efficiency on the 
    FPGA fabric.

2.2. BOOTH RADIX-8 ALGORITHM
Standard "Shift-and-Add" multipliers process 1 bit per clock cycle. 
This core uses the Booth Radix-8 algorithm, which processes 3 bits per cycle.

    Gain:
    This reduces the number of iterations required for an 8-bit multiplication
    from 8 cycles down to just 3 cycles.

2.3. CRITICAL PATH OPTIMIZATION: "LOOK-AHEAD 3M"
The bottleneck of the Radix-8 algorithm is the generation of the "3x Multiplicand"
term (calculated as M + 2M). In standard implementations, this adder sits inside
the iterative loop, limiting the maximum frequency (Fmax).

    Method:
    This design implements a "Look-Ahead" strategy. The 3M term is pre-calculated
    during the setup cycle (when the 'start' signal is asserted) and stored in a 
    dedicated register.
    During the computation loops, the logic selects the pre-calculated 
    value via a Multiplexer.

    Gain:
    This removes the adder from the main loop's critical path.
    - Before Optimization: ~111 MHz
    - After Optimization:  ~133 MHz (+20% Speedup)

2.4. ROBUST SIGNED/UNSIGNED HANDLING
The core supports four modes of operation via the 'sign_mode' input:
    - Unsigned x Unsigned
    - Unsigned x Signed
    - Signed x Unsigned
    - Signed x Signed

    Method:
    The internal 8-bit cores always perform arithmetic using signed logic to 
    maintain the validity of the Booth algorithm (which uses temporary negative
    partials). The Top-Level module handles the bit-extension and correction
    logic based on the selected mode.

3. PERFORMANCE BENCHMARKS
--------------------------------------------------------------------------------
Synthesis and Timing Analysis were performed using Yosys and Nextpnr for the
iCE40HX8K-CT256 FPGA (Speed Grade 1).

3.1. COMPARISON VS. STANDARD SERIAL MULTIPLIER

    METRIC              | STANDARD SERIAL     | BOOTH RADIX-8 (THIS CORE)
    --------------------|---------------------|--------------------------
    Max Frequency (Fmax)| 96.85 MHz           | 133.62 MHz
    Clock Cycles        | 17 Cycles           | 7 Cycles
    Total Time (Latency)| ~175.4 ns           | ~52.4 ns
    Logic Cells (Area)  | ~342 LCs            | ~488 LCs

3.2. ANALYSIS
    - Speed: The Booth core is 3.3x faster in total execution time compared
      to the standard serial approach.
    - Efficiency: The design achieves this speed with a moderate area increase
      (~146 Logic Cells), making it a highly efficient trade-off for 
      performance-critical applications.
    - Timing Closure: The reduced combinational depth allows the core to easily
      meet timing constraints in complex system-on-chip designs.

4. INTERFACE SPECIFICATIONS
--------------------------------------------------------------------------------
    PORT           | WIDTH | DIR | DESCRIPTION
    ---------------|-------|-----|--------------------------------------------
    clk            | 1     | IN  | System Clock
    rst_n          | 1     | IN  | Active-low Reset
    start          | 1     | IN  | One-cycle pulse to trigger multiplication
    multiplicand   | 16    | IN  | Operand A
    multiplier     | 16    | IN  | Operand B
    sign_mode      | 2     | IN  | 00:UxU, 01:UxS, 10:SxU, 11:SxS
    product        | 32    | OUT | Result (Available when done=1)
    done           | 1     | OUT | Pulse high when calculation completes
    busy           | 1     | OUT | High while operation is in progress

5. CONCLUSION
--------------------------------------------------------------------------------
The optimizations applied in this project successfully demonstrate that 
High-performance arithmetic is possible on low-cost FPGAs without dedicated 
DSP hardware. By combining algorithmic efficiency (Radix-8) with architectural 
pipelining (3M Pre-calculation), the core delivers industrial-grade performance
suitable for signal processing and real-time control applications.
